#!/usr/bin/env node
import * as t from "./type.js"
import * as fs from "fs"
import { array, command, multioption, option, optional, positional, run, string } from "cmd-ts"

const cmd = command({
  name: "pgts",
  description: `
  Generate typescript code to use with a PostgresT server.
`,
  args: {
    uri: positional({ displayName: "pg-uri", description: "The database URI" }),
    out: option({
      long: "outfile",
      short: "o",
      description: "The file to overwrite. If - or not provided, output on stdout",
      type: optional(string),
    }),
    schemas: multioption({
      long: "schemas",
      short: "s",
      description: "The schemas to include",
      type: array(string),
    })
  },
  async handler(opts) {
    await t.connect(opts.uri)
    console.error(`connected to ${opts.uri}`)
    console.error(`using schemas ${opts.schemas}`)
    let out: NodeJS.WritableStream = process.stdout

    let impl_blocks = new Map<string, string>()

    if (opts.out != null && opts.out !== "-") {
      try {
        const original = fs.readFileSync(opts.out, "utf-8")
        const re_block = /\/\*\*\s*!impl\s+([^\s]+)\s*\*\*\/([^]*?)\/\*\*\s*!end [^]*?\*\*\//gm
        // const re_block = /impl/gm
        // const re_block = /!impl\s+([^\s])/

        do {
          const m = re_block.exec(original)
          if (m == null) break
          if (m[2].trim()) impl_blocks.set(m[1].trim(), m[2])
        } while (true)

      } catch { }

      out = fs.createWriteStream(opts.out, "utf-8")
    }

    if (opts.schemas.length === 0) opts.schemas = ["public"]
    const schemas = new Set(opts.schemas)

    const POSTGREST_PATH = "/pg"

    out.write(`/**
   * WARNING
   * THIS FILE WAS GENERATED BY THE pgts UTIL
   * DO NOT EDIT THE CODE IN THIS FILE
   * https://github.com/ceymard/pgts
   */\n\n`)

    const w = (s: string) => { out.write(s) }

    w(`import { s, Model, POST } from "@salesway/pgts"\n`)
    w("\n")

    const header = impl_blocks.get("FILE_HEADER")
    w("/** !impl FILE_HEADER **/")
    if (header) {
      w(header)
    } else {
      w("\n")
    }
    w("/** !end impl FILE_HEADER **/\n\n")

    const tables = (await t.get_table_like()).sort((t1, t2) => {
      if (t1.schema < t2.schema) return -1
      if (t1.schema > t2.schema) return 1
      if (t1.name < t2.name) return -1
      if (t1.name > t2.name) return 1
      return 0
    })


    let last_schema = ""

    for (let t of tables) {
      const ww = (s: string) => w(`${s}`)
      const www = (s: string) => w(`  ${s}`)

      if (!schemas.has(t.schema)) continue
      if (t.isSystem) continue

      // console.error(`${t.displayKind} ${t.schema}.${t.name}`)

      w("\n")
      ww(`export class ${t.jsName} extends Model {\n`)

      // Pg url
      www(`static url = "${POSTGREST_PATH}/${t.name}"\n`)
      www(`static schema = "${t.schema}"\n`)

      // Primary key
      if (t.hasPrimaryKey) {
        www(`static pk = [${t.primary_keys.map(p => `"${p.name}"`).join(", ")}]\n`)
        www(`get __pk() { return {${t.primary_keys.map(c => `${c.name}: this.${c.name}`).join(", ")}} }\n`)
      }

      w("\n")


      const columns = t.columns.filter(c => !c.isSystem)

      let maxlen = Math.max(...columns.map(c => c.type.jsSerializer.length)) + 1
      if (maxlen % 2 === 0) maxlen += 1

      // Columns
      for (let c of columns) {
        let default_value = c.defaultExp

        www(`${`@${c.type.jsSerializer}`.padEnd(maxlen, " ")} ${c.name}${default_value ? "" : "!"}: ${c.typeName}${!default_value ? "": ` = ${default_value}`}${c.isPrimary ? " // [PK]" : ""} // ${c.default_exp}`)
        w("\n")
      }

      const cls_block = impl_blocks.get(t.jsName)
      w(`\n  /** !impl ${t.jsName} **/`)
      if (cls_block) {
        w(cls_block)
      } else {
        w("\n  ")
      }
      w(`/** !end impl ${t.jsName} **/\n\n`)

      w("}\n")
    }

    const fns = await t.get_functions()

    for (let fn of fns) {
      if (!schemas.has(fn.schema)) continue
      if (fn.isSystem || fn.isTrigger) continue
      // console.error("fn", `${fn.schema}.${fn.name}`)

      w(`\n\n`)
      w(`export function ${fn.name}(`)
      w(fn.args.map(a => `${a.name}: ${a.type.jsTypeNameExp}`).join(", "))
      w(`): Promise<${fn.returnTypeExp}${fn.returnsSet ? "[]" : ""}> {\n`)
      w(`  return POST("${fn.schema}", "${POSTGREST_PATH}/rpc/${fn.name}", JSON.stringify({${fn.args.map(a => a.name).join(", ")}}))\n`)
      if (fn._return_type.name !== "record" && fn.returnType.isComposite) {
        w(`    .then(result => s.deserialize(result${fn.returnsSet || fn.returnType.isArray ? " as unknown[]" : ""}, ${fn.returnType.jsName}))\n`)
      }
      if (!fn.returnsSet && !fn.returnType.isArray) {
        w(`    .then(result => Array.isArray(result) ? result[0] : result)\n`)
      }
      w(`}\n`)
    }


    if (out !== process.stdout) out.end()
    await t.end()

  }
})
run(cmd, process.argv.slice(2))

