#!/usr/bin/env node
import * as t from "./type.js"
import * as fs from "fs"
import { array, command, multioption, option, optional, positional, run, string } from "cmd-ts"

const cmd = command({
  name: "pgts",
  description: `
  Generate typescript code to use with a PostgresT server.
`,
  args: {
    uri: positional({ displayName: "pg-uri", description: "The database URI" }),
    out: option({
      long: "outfile",
      short: "o",
      description: "The file to overwrite. If - or not provided, output on stdout",
      type: optional(string),
    }),
    schemas: multioption({
      long: "schemas",
      short: "s",
      description: "The schemas to include",
      type: array(string),
    })
  },
  async handler(opts) {
    await t.connect(opts.uri)
    console.error(`connected to ${opts.uri}`)
    console.error(`using schemas ${opts.schemas}`)
    let out: NodeJS.WritableStream = process.stdout
    if (opts.out != null && opts.out !== "-") {
      out = fs.createWriteStream(opts.out, "utf-8")
    }

    if (opts.schemas.length === 0) opts.schemas = ["public"]
    const schemas = new Set(opts.schemas)

    const POSTGREST_PATH = "/pg"

    out.write(`/**
   * WARNING
   * THIS FILE WAS GENERATED BY THE pgts UTIL
   * DO NOT EDIT THE CODE IN THIS FILE
   * https://github.com/ceymard/pgts
   */\n\n`)

    const w = (s: string) => { out.write(s) }

    w(`import { autoserializeAs as a, Deserialize, s, Model, POST } from "@salesway/pgts"`)
    w("\n\n")

    const tables = (await t.get_table_like()).sort((t1, t2) => {
      if (t1.schema < t2.schema) return -1
      if (t1.schema > t2.schema) return 1
      if (t1.name < t2.name) return -1
      if (t1.name > t2.name) return 1
      return 0
    })


    let last_schema = ""

    for (let t of tables) {
      const ww = (s: string) => w(`${s}`)
      const www = (s: string) => w(`  ${s}`)

      if (!schemas.has(t.schema)) continue
      if (t.isSystem) continue

      console.error(`${t.displayKind} ${t.schema}.${t.name}`)

      w("\n")
      ww(`export class ${t.jsName} extends Model {\n`)

      // Pg url
      www(`static url = "${POSTGREST_PATH}/${t.name}"\n`)
      www(`static schema = "${t.schema}"\n`)

      // Primary key
      if (t.hasPrimaryKey) {
        www(`get __pk() { return [${t.columns.filter(c => c.isPrimary).map(c => `this.${c.name}`).join(", ")}] }\n`)
      }

      w("\n")

      // Columns
      for (let c of t.columns) {
        if (c.isSystem) continue

        www(`${`@a(${c.type.jsSerializer})`.padEnd(12, " ")} ${c.name}!: ${c.typeName} ${c.isPrimary ? "// [PK]" : ""}`)
        w("\n")
      }

      w("}\n")
    }

    const fns = await t.get_functions()

    for (let fn of fns) {
      if (!schemas.has(fn.schema)) continue
      console.error("fn", `${fn.schema}.${fn.name}`)

      w(`\n\n`)
      w(`export function ${fn.name}(`)
      w(fn.args.map(a => `${a.name}: ${a.type.jsTypeNameExp}`).join(", "))
      w(`): Promise<${fn.returnTypeExp}${fn.returnsSet ? "[]" : ""}> {\n`)
      w(`  return POST("${fn.schema}", "${POSTGREST_PATH}/rpc/${fn.name}", JSON.stringify({${fn.args.map(a => a.name).join(", ")}}))\n`)
      if (fn._return_type.name !== "record" && fn.returnType.isComposite) {
        w(`    .then(result => Deserialize(result, ${fn.returnType.jsSerializer}))\n`)
      }
      if (!fn.returnsSet && !fn.returnType.isArray) {
        w(`    .then(result => Array.isArray(result) ? result[0] : result)\n`)
      }
      w(`}\n`)
    }


    if (out !== process.stdout) out.end()
    await t.end()

  }
})
run(cmd, process.argv.slice(2))

