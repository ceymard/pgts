
import { autoserializeAs as aa, autoserialize as a, Deserialize, Serialize } from 'cerialize'

/** !impl FILE_HEADER **/
// Add your imports here
/** !end impl **/

/**
 * WARNING
 * THIS FILE IS GENERATED BY THE pgts UTIL
 * ONLY EDIT CODE WHERE STATED
 * BEWARE THAT CODE MAY DISAPPEAR IF THE CORRESPONDING TABLE CHANGES ITS NAME
 */

export const HstoreSerializer = {
  Serialize(hstore: Map<string, string>) {
    var res: string[] = []
    for (var [key, obj] of hstore) {
      res.push(`${key} => ${obj}`)
    }
    return res.join(', ')
  },
  Deserialize(json: any) {
    var res = new Map<string, string>()
    for (var key in json) {
      res.set(key, json[key])
    }
    return res
  }
}

/**
 * Convert the dates to and from UTC time since postgres is generally using UTC internally.
 */
export const UTCDateSerializer = {
  Serialize(date: any): any {
    if (date == null) return null
    date = new Date(date)
    const d = new Date(date.valueOf() - date.getTimezoneOffset() * 60000).toJSON()
    return d
  },
  Deserialize(date: any) {
    if (date instanceof Date) return date
    if (date == null) return null
    const d = new Date(date)
    return new Date(d.valueOf() + d.getTimezoneOffset() * 60000)
  }
}

export interface Json {
	[x: string]: string | number | boolean | Date | Json | JsonArray;
}
export type Jsonb = Json

export interface JsonArray extends Array<string | number | boolean | Date | Json | JsonArray> { }


export interface ModelMaker<T extends Model> {
  new (): T
  url: string
}


export function FETCH(input: RequestInfo, init?: RequestInit): Promise<Response> {
  /** !impl FETCH_PRELUDE **/
  // override here the way fetch should work globally
  return fetch(input, init).then(res => {
  	if (res.status < 200 || res.status >= 400)
  	  return Promise.reject(res)
  	return res
  })
  /** !end impl **/
}


export function GET(url: string) {
  return FETCH(url, {
    method: 'GET',
    headers: {
      Accept: 'application/json',
      'Content-Type': 'application/json'
    },
    credentials: 'include'
  }).then(res => {
  	return res.json()
  })
}

export function DELETE(url: string) {
  return FETCH(url, {
    method: 'DELETE',
    headers: {
      Accept: 'application/json',
      'Content-Type': 'application/json'
    },
    credentials: 'include'
  }).then(res => {
  	return res.text() as any
  })
}



export async function POST(url: string, body: any = {}): Promise<any> {
  return FETCH(url, {
    method: 'POST',
    headers: {
      Accept: 'application/json',
      'Content-Type': 'application/json'
    },
    credentials: 'include',
    body: body
  }).then(res => {
    return res.json()
  })
}


export class Model {
  static url = ''
  static pk: string[] = []

  static async get<T extends Model>(this: ModelMaker<T>, supl: string = ''): Promise<T[]> {
    // const ret = this as any as (new () => T)
    const res = await GET(this.url + supl)
    return Deserialize(res, this)
  }

  static async remove<T extends Model>(this: ModelMaker<T>, supl: string) {
    if (!supl)
      throw new Error('suppl cannot be empty')
    if (supl[0] !== '?') supl = '?' + supl
    const res = await DELETE(this.url + supl)
    return res
  }

  static async saveMany<T extends Model>(this: ModelMaker<T>, models: T[]) {
    if (!models.length) return []

    const heads = new Headers({
      Accept: 'application/json',
      Prefer: 'resolution=merge-duplicates',
      'Content-Type': 'application/json'
    })
    heads.append('Prefer', 'return=representation')

    const res = await FETCH(this.url, {
      method: 'POST',
      headers: heads,
      credentials: 'include',
      body: JSON.stringify(models.map(m => Serialize(m)))
    })

    return Deserialize((await res.json()), this) as T[]
  }

  async save(keys?: (keyof this)[]): Promise<this> {
    const heads = new Headers({
      Accept: 'application/json',
      Prefer: 'resolution=merge-duplicates',
      'Content-Type': 'application/json'
    })
    heads.append('Prefer', 'return=representation')
    const res = await FETCH((this.constructor as any).url + (keys && keys.length > 0 ? `?columns=${keys.join(',')}` : ''), {
      method: 'POST',
      headers: heads,
      credentials: 'include',
      body: JSON.stringify(Serialize(this))
    })

    const payload = (await res.json())[0]
    const n = Deserialize(payload, this.constructor)
    return n
  }

  async update(...keys: (keyof this)[]): Promise<this> {
    const heads = new Headers({
      Accept: 'application/json',
      Prefer: 'resolution=merge-duplicates',
      'Content-Type': 'application/json'
    })
    heads.append('Prefer', 'return=representation')
    var _pk = ((this.constructor as any).pk as string[]).map(p => `${p}=eq.${(this as any)[p]}`).join('&')
    const res = await FETCH((this.constructor as any).url + '?' + _pk + (keys && keys.length > 0 ? `&columns=${keys.join(',')}` : ''), {
      method: 'PATCH',
      headers: heads,
      credentials: 'include',
      body: JSON.stringify(Serialize(this))
    })

    const payload = (await res.json())[0]
    const n = Deserialize(payload, this.constructor)
    return n
  }

  /** !impl Model **/
  // Add methods to model here
  /** !end impl **/
}

