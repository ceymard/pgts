
import { autoserializeAs as aa, autoserialize as a, Deserialize, Serialize } from "cerialize"

/** !impl FILE_HEADER **/
// Add your imports here
/** !end impl **/

/**
 * WARNING
 * THIS FILE IS GENERATED BY THE pgts UTIL
 * ONLY EDIT CODE WHERE STATED
 * BEWARE THAT CODE MAY DISAPPEAR IF THE CORRESPONDING TABLE CHANGES ITS NAME
 */

function pad(v: number): string {
  return v > 0 && v < 10 ? "0" + v : "" + v
}

/** Date objects are generally created with timezones, and we want to strip out the timezone portion */
export function format_date_iso(d: Date): string {
  return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`
}

export const HstoreSerializer = {
  Serialize(hstore: Map<string, string>) {
    const res: string[] = []
    for (const [key, obj] of hstore) {
      res.push(`${key} => ${obj}`)
    }
    return res.join(", ")
  },
  Deserialize(json: any) {
    const res = new Map<string, string>()
    for (const key in json) {
      res.set(key, json[key])
    }
    return res
  }
}

export type Json = any
export type Jsonb = Json


export type ModelMaker<T extends Model> = {new(...a: any): T} & Pick<typeof Model, keyof typeof Model>

export const sym_count = Symbol("count")
export type RequestCount = {total: number, first: number, last: number}

function to_update_arg(v: any) {
  if (v == null) return "is.null"
  if (v instanceof Date) return `eq.${v.toJSON()}`
  // if (typeof v === "string") return `eq."${v.replace(/"/g, "\\\"")}"`
  if (typeof v === "boolean") return `is.${v}`
  return `eq.${v}`
}

export function FETCH(input: RequestInfo, init?: RequestInit): Promise<Response> {
  /** !impl FETCH_PRELUDE **/
  // override here the way fetch should work globally
  return fetch(input, init).then(res => {
    if (res.status < 200 || res.status >= 400)
      return Promise.reject(res)
    return res
  })
  /** !end impl **/
}


export function GET(url: string, opts: { exact_count?: boolean } = { }) {
  return FETCH(url, {
    method: "GET",
    headers: {
      Accept: "application/json",
      "Content-Type": "application/json",
      ...(opts.exact_count ? { Prefer: "count=exact" } : {}),
    },
    credentials: "include"
  }).then(async res => {
    const result = await res.json()
    const head = res.headers.get("Content-Range")
    if (opts.exact_count && head) {
      const [strbegin, strtotal] = head.split("/")
      const total = parseInt(strtotal)
      const [strfirst, strlast] = strbegin.split("-")
      const first = parseInt(strfirst)
      const last = parseInt(strlast)
      const pagecount = total / (first - last + 1)
      result[sym_count] = {total, first, last, pagecount}
    } else {
      result[sym_count] = {total: NaN, first: NaN, last: NaN, pagecount: NaN}
    }
    return result
  })
}

export function DELETE(url: string) {
  return FETCH(url, {
    method: "DELETE",
    headers: {
      Accept: "application/json",
      "Content-Type": "application/json"
    },
    credentials: "include"
  }).then(res => {
    return res.text() as any
  })
}



export async function POST(url: string, body: any = {}): Promise<any> {
  return FETCH(url, {
    method: "POST",
    headers: {
      Accept: "application/json",
      "Content-Type": "application/json"
    },
    credentials: "include",
    body: body
  }).then(res => {
    return res.json()
  })
}


export const Cons = Symbol("constructor")
export const OldPk = Symbol("oldpk")


export abstract class Model {
  abstract get [Cons](): typeof Model;
  [OldPk]!: any[]
  static url = ""
  static pk: string[] = []

  static async get<T extends Model>(this: ModelMaker<T>, supl: string = "", opts: { exact_count?: boolean } = {}): Promise<T[] & {[sym_count]: RequestCount}> {
    // const ret = this as any as (new () => T)
    const res = await GET(this.url + supl, opts)
    const res_t = Deserialize(res, this)
    for (const r of res_t) {
      r[OldPk] = this.pk.map(k => (r as any)[k])
    }
    if (opts.exact_count && res[sym_count]) res_t[sym_count] = res[sym_count]
    return res_t
  }

  static async remove<T extends Model>(this: ModelMaker<T>, supl: string) {
    if (!supl)
      throw new Error("suppl cannot be empty")
    if (supl[0] !== "?") supl = "?" + supl
    const res = await DELETE(this.url + supl)
    return res
  }

  static async saveMany<T extends Model>(this: ModelMaker<T>, models: T[]) {
    if (!models.length) return []

    const heads = new Headers({
      Accept: "application/json",
      Prefer: "resolution=merge-duplicates",
      "Content-Type": "application/json"
    })
    heads.append("Prefer", "return=representation")

    const res = await FETCH(this.url, {
      method: "POST",
      headers: heads,
      credentials: "include",
      body: JSON.stringify(models.map(m => Serialize(m, this)))
    })

    const res_t = Deserialize((await res.json()), this) as T[]
    for (const r of res_t) {
      r[OldPk] = this.pk.map(k => (r as any)[k])
    }
    return res_t
  }

  protected async doSave(url: string, method: string): Promise<this> {
    const heads = new Headers({
      Accept: "application/json",
      Prefer: "resolution=merge-duplicates",
      "Content-Type": "application/json"
    })
    heads.append("Prefer", "return=representation")
    const res = await FETCH(url, {
      method: method,
      headers: heads,
      credentials: "include",
      body: JSON.stringify(Serialize(this, this[Cons]))
    })

    const payload = (await res.json())[0]
    const n = Deserialize(payload, this[Cons])
    n[OldPk] = this[Cons].pk.map(k => (this as any)[k])
    return n
  }

  /**
   * Save upserts the record.
   */
  async save() {
    if (this[OldPk])
      return this.update()
    return this.doSave(this[Cons].url, "POST")
  }

  /**
   * Update just updates the record.
   */
  async update(...keys: (keyof this)[]): Promise<this> {
    const parts: string[] = []
    const cst = this[Cons]
    const pk = cst.pk
    if (!pk || pk.length === 0) {
      throw new Error("can't instance-update an item without primary key")
    }
    for (let i = 0; i < pk.length; i++) {
      parts.push(`${pk[i]}=${to_update_arg(this[OldPk][i])}`)
    }

    if (keys.length) {
      parts.push(`columns=${keys.join(",")}`)
    }

    return this.doSave(cst.url + (parts.length ? `?${parts.join("&")}` : ""), "PATCH")
  }

  async delete(): Promise<Response> {
    const cst = this[Cons]
    if (!cst.pk || cst.pk.length === 0) {
      throw new Error("can't instance-delete an item without primary key")
    }
    const parts: string[] = []
    for (const pk of cst.pk) {
      parts.push(`${pk}=${to_update_arg((this as any)[pk])}`)
    }
    return FETCH(`${cst.url}?${parts.join("&")}`, {
      method: "DELETE",
      credentials: "include",
    })
  }

  /** !impl Model **/
  // Add methods to model here
  /** !end impl **/
}

